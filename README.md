# hello-world
第一次尝试


java开头
/*

需求：xxxxxx程序；xxxxx实现xx功能；

思路（代码思想）：
	1，定义一个类，因为java程序都定义在类中，java程序都是以类的形式存在的，类的形式就是一个	       字节码文件最终体现
	2，定义一个主函数。为了让该类可以独立运行。
	3，因为要实现xxx功能，需要什么语句完成。

步骤：
	1用class关键字来完成类的定义，并起一个阅读性强的类名
	2，主函数：public static void main（String[] args）这是固定格式，jvm认识
	3，使用哪些语句。

代码仅仅是思想的一种体现形式。

*/



jre：jvm（虚拟机）+java类库
jdk：jre+java的开发工具
jdk开发完成java程序，交给jre去运行   



与(&)运算有一边结果为false，结果为false
&：无论左边的运算结果是什么，右边都参与运算。
&&：当左边为false时，右边不参与运算。

或(|)运算有一边结果为true，结果为true

异或(^)的两边结果相同，结果为false
异或的两边结果不同，结果为true
a^b^b=a  一个数异或同一个数两次，得到原来的值。



<<左移几位其实就是该数据乘以2的几次方，可以完成2的次幂运算

>>右移几位其实就是该数据除以2的几次幂
对于高位出现的空位，原来高位是用什么就用什么补这个空位
>>>:无符号右移；数据进行右移时，高位出现的空位，无论原来高位是什么，空位都用0补


运算符一定有结果，不管是几元的

三元运算符  （三元运算符就是if else 语句简写格式）
（当if else 运算后，有一个具体的结果时，可以简化写成三元运算符）
（条件表达式）？表达式1：表达式2;
如果条件为true，运算后的结果是表达式1；
如果条件为false，运算后的结果是表达式2；



两个整数互换，不借助第三个变量
int a=3,b=5;
a=a+b;
b=a-b;
a=a-b;
缺点：两个整数数值过大，会超出int范围，会强制转换，数据会变化
a=a^b;
b=a^b;
a=a^b;
异或运算：1个数异或 同一个数两次，得到原来的值。


if：
	1，对具体的值进行判断
	2，对区间判断	
	3，对运算结果是boolean类型的表达式进行判断
switch：
	1，对具体的值进行判断
	2，值的个数通常是固定的
	对于几个固定的值判断，建议使用switch语句，因为switch语句会将具体的答案都加载进内存，效率相对高一点。

当对一个条件进行一次判断时，可以使用if语句。
当对一个条件进行多次判断时，可以使用while语句。

注意：
	在使用循环时，一定要明确哪些语句需要参与循环，那些不需要。
	循环通常情况下，需要定义条件，需要控制次数。




break：跳出所在当前循环。如果出现了循环嵌套，break先要跳出指定的循环，可以通过标号来完成。
continue：继续。作用范围:循环结构。继续本次循环，继续下次循环



函数：在类中具有特定功能的小程序
函数就是方法
函数重载：在同一个类中，允许存在一个以上的同名函数。参数个数不同或参数类型不同
函数重载和返回值类型无关。java是严谨性语言，如果函数出现调用的不确定性，会编译失败。




数组格式1：
元素类型[] 数组名 = new 元素类型[元素个数或数组长度];
示例： int[] arr = new int [5];
数组格式2：
元素类型[]数组名 = new 元素类型[]{元素，元素，……};
int[] arr = new int []{1,3,5,7};
int[] arr = {3,5,1,7};



内存的划分：
1.寄存器
2.本地方法区
3.方法区
4.栈内存
	存储的都是局部变量。
	而且变量所属的作用域一旦结束，该变量就自动释放。
5.堆内存
	存储的是数组和对象（其实数组就是对象）凡是new建立的都在堆中。
	特点：
	1，每一个实体都有一个首地址值。
	2，堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。整数类型是0，
小数类型是0.0或者0.0f，boolean类型是 false，char类型是‘\u0000’
	3，垃圾回收机制


数组:
int[] arr = new int[3];
System.out.println(arr[3]);//ArrayIndexOutOfBoundsException:
    //当访问到数组中不存在的角标时，就会发生该异常。

arr = null;
System.out.println(arr[0]);//NullPointerException
    //当引用型变量没有任何实数指向时，还在用其操作实体，就会发生该异常



1  “+”连接两个字符串


2  	byte short int long   1个byte有8个bit位，short有2个byte，int有4个byte，long有8个byte
	整数默认int型

	short s = 3；
	s+=4；   
	s = s + 4；
	区别在于  s+=4；会在底层做强制类型转换（提升），而s=s+4；不做类型转换，所以不能将得到的值强制赋给低空间类型（short）
        short s = 3；
	s = s + 4；会报错，（精度丢失）原因如上。
 
3   InputMismatchException   输入不匹配异常  










